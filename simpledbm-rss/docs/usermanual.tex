\documentclass[a4paper,draft,oneside]{book}
\begin{document}
\title{SimpleDBM User's Manual}
\author{Dibyendu Majumdar\\
dibyendu@mazumdar.demon.co.uk\\
Copyright \copyright 2007}
\date{Revised \today}
\maketitle
%\setlength{\parindent}{0pt}
%\setlength{\parskip}{\baselineskip}
\tableofcontents

\chapter{Introduction}

\section{Overview}
SimpleDBM is a transactional storage engine, written in Java. It has a
very small footprint and can be embedded in the address space of an
application. It provides a simple programming API, which can be
learned very quickly.

\section{Features}
SimpleDBM has the following features:
\begin{enumerate}
    \item Transactional - SimpleDBM fully supports ACID transactions. A STEAL and NO-FORCE buffer mangement strategy is used for transactions which is optimum for performance.
    \item Multi-threaded - SimpleDBM is multi-threaded and supports concurrent reads and writes of data.
    \item Write Ahead Log - SimpleDBM uses a write ahead log to ensure transaction recovery in the event of system crashes.
    \item Lock based concurrency - SimpleDBM uses shared, update and exclusive locks to manage concurrency. Row locks are used.
    \item Multiple Isolation Levels - SimpleDBM supports read committed, repeatable read, and serializable isolation levels.
    \item B-Tree Indexes - SimpleDBM implements B-plus Tree indexes, that fully support concurrent reads, inserts and deletes. SimpleDBM B-Trees continually rebalance themselves, and do not suffer from fragmentation.
    \item Tables - SimpleDBM supports tables, but for maximum flexibility, treats table rows as blobs of data. Table rows can have any internal structure as you like, and can span multiple disk pages.
    \item Latches and Locks - SimpleDBM uses latches for internal consistency, and locks for concurrency. Latches are more efficient locking mechanisms that do not suffer from deadlocks.
    \item Deadlock detection - SimpleDBM has support for deadlock detection. A background thread periodically checks the lock table for deadlocks and aborts transactions to resolve deadlocks.
\end{enumerate}

\section{Status}
SimpleDBM is currently in early BETA and not suitable for use in Production systems. The latest builds can be downloaded from:

http://code.google.com/p/simpledbm/downloads/list.

\section{Getting Started}
Download the latest build of SimpleDBM.
There are no special requirements or third party library dependencies; all you
need to ensure is that the SimpleDBM jar file is in your classpath.

SimpleDBM does not come with a type system of its own, but there is a sample
typesystem implementation available, which you can enhance. 

\chapter{Common Infrastructure}

\section{ObjectRegistry}
In any object oriented persistence system, there has to be a mechanism
for creating objects dynamically, given some form of type
identification. SimpleDBM uses a simple Object Registry database for
this purpose. Each class that may be dynamically instantiated is
assigned a unique type code. The type code and the associated class
name is registered in the SimpleDBM Object Registry. The typecode can
subsequently be used to request an object of the specified class.

SimpleDBM's Object Registry is a very basic mechanism, and only
supports programmatic registration of types. In addition to
registering types, you can also register Singletons.

The Object Registry is important because it provides
coupling between SimpleDBM and clients. For instance, index key
types, table row types, etc. can be registered in SimpleDBM's
Object Registry and thereby made available to SimpleDBM. You will
see how this is done when we discuss Indexes and Tables.

\section{Registering a type}
To allow SimpleDBM to access a particular type, you must assign a
unique 2-byte (short) typecode to the type, and register it with the
ObjectRegistry. Note that because the typecode is recorded in
persistent storage, it must be stable, i.e., it must not change within
the scope of a database. Also, ensure that you have registered all the
required types prior to starting a SimpleDBM database instance.

Note that typecodes between the range 0-1000 are reserved for use by
SimpleDBM.

Following example shows how to register a type with SimpleDBM's Object
Registry.

\begin{verbatim}
// We assume that a SimpleDBM server instance is available
Server server;		

// Let's assume we would like to register a type called
// IntegerKey, and assign it the unique code 7001. 
server.getObjectRegistry().registerType(7001,
  org.simpledbm.samples.usermanual.im.IntegerKey.class.getName());
\end{verbatim}

Above registers the \verb|IntegerKey| class with the Object Registry. It
assigns the type code 7001 to the \verb|IntegerKey| class. Objects of the
registered classes may be instantiated using their type codes:

\begin{verbatim}
IntegerKey key = (IntegerKey) 
  server.getObjectRegistry().getInstance(7001);
\end{verbatim}

For a class to be eligible for registration, it must implement the
default no-argument constructor.

\section{Registering Singletons}
SimpleDBM's object registry also supports registration of
singletons via the \verb|registerSingleton()| method. 

\section{Storable Interface and Object serialization}
SimpleDBM requires some way of serializing and de-serializing
objects from a byte stream. Java provides the \verb|java.io.Serializable|
interface and associated technology for this, however, the default
mechanism is unsuitable for use in SimpleDBM. The problem with the
default method is that the language decides how to map type
information to the stream. Since this has to be done in a generic
manner, it cannot be optimised for space. In contrast, SimpleDBM can
use the 2-byte short integer type code used in the Object Registry
module to efficiently store type information.

SimpleDBM provides the \verb|org.simpledbm.rss.api.st.Storable|
interface as a substitute for \verb|java.io.Serializable| interface. The
\verb|Storable| interface requires the implementation to be able to predict
its persistent size in bytes when the \verb|getStoredLength()| method is invoked. It
also requires the implementation to be able to stream itself to a
\verb|ByteBuffer| object, and also restore its contents from a
\verb|ByteBuffer| object.

The Storable interface specification is as follows:

\begin{verbatim}
/**
 * A Storable object can be written to (stored into) or 
 * read from (retrieved from) a ByteBuffer. The object 
 * must be able to predict its length in bytes;
 * this not only allows clients to allocate ByteBuffer 
 * objects of suitable size, it is also be used by a 
 * StorageContainer to ensure that objects can be
 * restored from secondary storage.
 */
public interface Storable {

  /**
   * Retrieve the object from the supplied ByteBuffer. 
   * ByteBuffer is assumed to be setup correctly for 
   * reading.
   * 
   * @param bb ByteBuffer that contains a stored 
   *           representation of the object.
   */
  void retrieve(ByteBuffer bb);

  /**
   * Store this object into the supplied ByteBuffer in 
   * a format that can be subsequently retrieved using 
   * retrieve(). ByteBuffer is assumed to be setup 
   * correctly for writing.
   * 
   * @param bb ByteBuffer that will contain a stored 
   *           representation of the object.
   */
  void store(ByteBuffer bb);

  /**
   * Predict the length of this object in bytes when 
   * stored in a ByteBuffer.
   * 
   * @return The length of this object when stored in 
   *         a ByteBuffer.
   */
  int getStoredLength();
}
\end{verbatim}

An example implementation of the \verb|Storable| interface is 
given below:

\begin{verbatim}
public final class ByteString implements Storable {
    
  private byte[] bytes;
    
  public int getStoredLength() {
    return bytes.length + 2;
  }
    
  public void store(ByteBuffer bb) {
    short n = 0;
    if (bytes != null) {
      n = (short) bytes.length;
    }
    bb.putShort(n);
    if (n > 0) {
      bb.put(bytes, 0, n);
    }
  }
    
  public void retrieve(ByteBuffer bb) {
    short n = bb.getShort();
    if (n > 0) {
      bytes = new byte[n];
      bb.get(bytes);
    }
    else {
      bytes = new byte[0];
    }
  }
}
\end{verbatim}

A coding standard in SimpleDBM is to make sure that Storable
objects are immutable. Once created, a Storable object can 
only mutate when it is re-constructed from a byte stream using the
retrieve() method. Another precaution taken is to ensure that
retrieve() creates new instances of any Storable member objects rather
than modifying these - again keeping with the philosophy of immutability
of Storable objects. 

\chapter{SimpleDBM Servers and Databases}

\section{Introduction}

A SimpleDBM server is a set of background threads and a library of API
calls that clients can hook into. The background threads take care of
various tasks, such as writing out buffer pages, writing out logs,
archiving older log files, creating checkpoints, etc.

A SimpleDBM server operates on a set of data and index files, known as
the SimpleDBM database.

Only one server instance is allowed to access a SimpleDBM database at
any point in time. SimpleDBM uses a lock file to detect multiple
concurrent access to a database, and will refuse to start if it
detects that a server is already accessing a database.

Internally, SimpleDBM operates on Containers. Externally, Containers
are mapped to files. Tables and Indexes are stored in Containers known
as TupleContainers and IndexContainers.

The SimpleDBM database initially consists of a set of transaction log
files, a lock file and a special container used internally by
SimpleDBM.

\section{Creating a SimpleDBM database}

A SimpleDBM database is created by a call to Server.create(), as shown
below:

\begin{verbatim}
import org.simpledbm.rss.main.Server;

...

Properties properties = new Properties();
properties.setProperty("log.ctl.1", "ctl.a");
properties.setProperty("log.ctl.2", "ctl.b");
properties.setProperty("log.groups.1.path", ".");
properties.setProperty("log.archive.path", ".");
properties.setProperty("log.group.files", "3");
properties.setProperty("log.file.size", "16384");
properties.setProperty("log.buffer.size", "16384");
properties.setProperty("log.buffer.limit", "4");
properties.setProperty("log.flush.interval", "5");
properties.setProperty("storage.basePath", "demodata/TupleDemo1");

Server.create(properties);
\end{verbatim}

The Server.create() method accepts a Properties object as
the sole argument. The Properties object can be used to pass a
number of parameters. 

\begin{table}[h]
\begin{tabular}{|l|p{6cm}|}
  \hline
  \textbf{Property Name}&\textbf{Description}  \\
  \hline 
  \verb|log.ctl.{n}|&The fully qualified path to the
  log control file. The first file should be specified as
  \verb|log.ctl.1|, second as \verb|log.ctl.2|, and so on. Up to a
  maximum of 3 can be specified. Default is 2. \\
  \hline
  \verb|log.groups.{n}.path|&The path where log
  files of a group should be stored. The first log group is specified
  as \verb|log.groups.1.path|, the second as \verb|log.groups.2.path|,
  and so on. Up to a maximum of 3 log groups can be specified. Default
  number of groups is 1. Path defaults to current directory.  \\
  \hline
  \verb|log.archive.path|&Defines the path for storing archive files. 
  Defaults to current directory.  \\
  \hline
  \verb|log.group.files|&Specifies the number of log files within each group.
  Up to a maximum of 8 are allowed. Defaults to 2. \\
  \hline 
  \verb|log.file.size|&Specifies the size of each log file in
  bytes. Default is 2 KB. \\
  \hline 
  \verb|log.buffer.size|&Specifies the size of the log buffer
  in bytes. Default is 2 KB. \\
  \hline 
  \verb|log.buffer.limit|&Sets a limit on the maximum number of
  log buffers that can be allocated. Default is 10 *
  \verb|log.group.files|.  \\
  \hline 
  \verb|log.flush.interval|&Sets the interval (in seconds)
  between log flushes. Default is 6 seconds.  \\
  \hline 
  \verb|log.disableExplicitFlushRequests|&Boolean value, if set, disables 
  log flushes requested explicitly by the Buffer Manager or Transaction 
  Manager. Log flushes still occur during checkpoints and log switches. 
  By reducing the log flushes, performance is improved, but transactions 
  may not be durable. Only those transactions will survive a system crash 
  that have all their log records on disk.  \\
  \hline 
  \verb|storage.basePath|&Defines the base location of the
  SimpleDBM database. All files and directories are created relative to this
  location.  \\
  \hline 
  \verb|storage.createMode|&Defines mode in which files will be
  created. Default is ``rws''.  \\
  \hline 
  \verb|storage.openMode|&Defines mode in which files will be
  opened. Default is ``rws''.  \\
  \hline 
  \verb|bufferpool.numbuffers|&Sets the number of buffers to be created in 
  the Buffer Pool.  \\
  \hline 
  \verb|bufferpool.bufferWriterSleepInterval|&Sets the interval in 
  milliseconds between each run of the BufferWriter. Note that BufferWriter 
  may run earlier than the specified interval if the pool runs out of 
  buffers, and a new page has to be read in. In such cases, the Buffer Writer
  may be manually triggered to clean out buffers.  \\
  \hline
\end{tabular}
\label{tab2} \caption{Log Options}
\end{table}

The Server.create() call will overwrite any existing database
in the specified storage path, so it must be called only when you know
for sure that you want to create a database.

\section{Opening a database}

Once a database has been created, it can be opened by creating an
instance of SimpleDBM server, and starting it. The same properties that were
supplied while creating the database, can be supplied when starting it.

Here is a code snippet that shows how this is done:

\begin{verbatim}
Properties properties = new Properties();
properties.setProperty("log.ctl.1", "ctl.a");
properties.setProperty("log.ctl.2", "ctl.b");
properties.setProperty("log.groups.1.path", ".");
properties.setProperty("log.archive.path", ".");
properties.setProperty("log.group.files", "3");
properties.setProperty("log.file.size", "16384");
properties.setProperty("log.buffer.size", "16384");
properties.setProperty("log.buffer.limit", "4");
properties.setProperty("log.flush.interval", "5");
properties.setProperty("storage.basePath", "demodata/TupleDemo1");

Server server = new Server(properties);
server.start();
try {
  // do some work
}
finally {
  server.shutdown();
}
\end{verbatim}

Some points to bear in mind when starting SimpleDBM server instances:

\begin{enumerate}
\item Make sure that you invoke shutdown() eventually to ensure proper
  shutdown of the database.
\item Database startup/shutdown is relatively expensive, so do it only
  once during the life-cycle of your application.
\item A Server object can be used only once - after calling
  shutdown(), it is an error to do any operation with the server
  object.
\end{enumerate}

\chapter{Transactions}

Most SimpleDBM operations take place in the context of a Transaction.
Following are the main API calls for managing transactions.

\section{Creating new Transactions}

To start a new Transaction, invoke the Server.begin() method as 
shown below. You must supply an IsolationMode, try \verb|READ_COMMITTED| to
start with.

\begin{verbatim}
Server server = ...;

// Start a new Transaction
Transaction trx = server.begin(IsolationMode.READ_COMMITTED);

\end{verbatim}

The Transaction interface provides the following methods for
clients to invoke:

\begin{verbatim}
public interface Transaction {
	
  /**
   * Creates a transaction savepoint.
   */
  public Savepoint createSavepoint(boolean saveCursors);

  /**
   * Commits the transaction. All locks held by the
   * transaction are released.
   */
  public void commit();	

  /**
   * Rolls back a transaction upto a savepoint. Locks acquired
   * since the Savepoint are released. PostCommitActions queued
   * after the Savepoint was created are discarded.
   */
  public void rollback(Savepoint sp);	

  /**
   * Aborts the transaction, undoing all changes and releasing locks.
   */
  public void abort();	

}
\end{verbatim}

A transaction must always be either committed or aborted. Failure to do
so will lead to resource leaks, such as locks, which will not be released.
The correct way to work with transactions is shown below:

\begin{verbatim}
// Start a new Transaction
Transaction trx = server.begin(IsolationMode.READ_COMMITTED);
boolean success = false;
try {
  // do some work and if this is completed succesfully ...
  // set success to true.
  doSomething();
  success = true;
}
finally {
  if (success) {
    trx.commit();
  }
  else {
    trx.abort();
  }
}
\end{verbatim}

\chapter{Tables}

\section{TupleContainers}

SimpleDBM provides support for tables with variable length records.
These are known as TupleContainers.  As far as SimpleDBM is concerned,
a row in a TupleContainer is just a blob of data; it can contain
anything you like. SimpleDBM will automatically break up a large row
into smaller chunks so the chunks can be stored in individual data
pages. This chunking is transparent from a client perspective, as the
client only ever sees full records.

\section{Creating a TupleContainer}

When you create a TupleContainer, you must supply a name for the
container, a unique numeric ID which should not be in use by any other
container, and the extent size. For efficiency, SimpleDBM allocates
space in extents; an extent is logically a set of contiguous pages.

\begin{verbatim}
/**
 * Creates a new Tuple Container. 
 * 
 * @param trx Transaction to be used for creating the container
 * @param name Name of the container
 * @param containerId A numeric ID for the container - must be unique 
 *        for each container
 * @param extentSize The number of pages that should be part of each 
 *        extent in the container
 */
public void createTupleContainer(Transaction trx, String name,
 int containerId, int extentSize);
\end{verbatim}

Note that the createTupleContainer() method requires a Transaction.
Given below is an example of how a tuple container may be created.

\begin{verbatim}
Transaction trx = server.begin(IsolationMode.READ_COMMITTED);
boolean success = false;
try {
  server.createTupleContainer(trx, "test.db", 1, 20);
  success = true;
}
finally {
  if (success)
    trx.commit();			
  else 
    trx.abort();
}
\end{verbatim}

\section{Accessing a TupleContainer}


\chapter{Indexes}


\section{Index Keys}

Index Keys are the searchable attributes stored in the Index. This module
specifies Index Keys in a fairly general way:

\begin{verbatim}
public interface IndexKey extends Storable, Comparable<IndexKey> {
	
  /**
   * Used mainly for building test cases; this method should
   * parse the input string and initialize itself. The contents 
   * of the string is expected to match the toString() output.
   */
  void parseString(String string);
}
\end{verbatim}

The requirements for an IndexKey are fairly simple. The key must be
Storable and Comparable. Note that this interface does not say anything
about the internal structure of the key; in particular it does not 
specify whether the key contains multiple attributes. This is deliberate,
as it makes the Index Manager module more generic.

Depending upon the implementation, there may be restricions on the
size of the key. For instance, in a BTree implementation, the key
should not exceed 1/8th of the page size, ie, 1KB in a 8KB page. 

\section{Index Key Factories}

An Index Key Factory is used to create new keys. In addition to normal keys, an Index
Key Factory must be able to create two special type of keys:

\begin{itemize}
	\item \textbf{MinKey} - this is a special key that represents negative infinity. All valid keys must be greater than this key.
	\item \textbf{MaxKey} - this is a special key that represents positive infinity. All valid keys must be less than this key.
\end{itemize}

The special keys are used by the Index Manager internally.

\begin{verbatim}
public interface IndexKeyFactory {

  /**
   * Generates a new (empty) key for the specified
   * Container. The Container ID is meant to be used as key
   * for locating information specific to a container; for instance,
   * the attributes of an Index.
   * 
   * @param containerId ID of the container for which a key is required
   */
  IndexKey newIndexKey(int containerId);

  /**
   * Generates a key that represents Infinity - it must be greater than
   * all possible keys in the domain for the key.  The Container ID is meant to be used as key
   * for locating information specific to a container; for instance,
   * the attributes of an Index.
   * 
   * @param containerId ID of the container for which a key is required
   */
  IndexKey maxIndexKey(int containerId);
	
  /**
   * Generates a key that represents negative Infinity - it must be smaller than
   * all possible keys in the domain for the key. The Container ID is meant to be used as key
   * for locating information specific to a container; for instance,
   * the attributes of an Index.
   *
   * The key returned by this method can be used as an argument to index scans.
   * The result will be a scan of the index starting from the first key in 
   * the index.
   * 
   * @param containerId ID of the container for which a key is required
   */
  IndexKey minIndexKey(int containerId);
}
\end{verbatim}

An implementation is free to use any method it likes for 
identifying keys that represent ``MinKey'' and ``MaxKey'', as long as it ensures
that these keys will obey the contract defined above.

The methods of \verb|IndexKeyFactory| take the container ID as
a parameter. In SimpleDBM, each index is stored in a separate container,
hence container ID is used as a mechanism for identifying the index.
The \verb|IndexKeyFactory| implementation is expected to use the
container ID to determine the type of index key to create. For example, it may
consult a data dictionary to determine the type of key attributes required
by the index key.

\section{Example}

Given below is an example of an \verb|IndexKey| implementation. This 
implementation uses a special byte field to maintain the status information.

\begin{verbatim}
public class IntegerKey implements IndexKey {

  private static final byte NULL_FIELD = 1;
  private static final byte MINUS_INFINITY_FIELD = 2;
  private static final byte VALUE_FIELD = 4;
  private static final byte PLUS_INFINITY_FIELD = 8;

  private byte statusByte = NULL_FIELD;
  private int value;

  public IntegerKey() {
    statusByte = NULL_FIELD;
  }

  public IntegerKey(int value) {
    statusByte = VALUE_FIELD;
    this.value = value;
  }

  protected IntegerKey(byte statusByte, int value) {
    this.statusByte = statusByte;
    this.value = value;
  }

  public int getValue() {
    if (statusByte != VALUE_FIELD) {
      throw new IllegalStateException("Value has not been set");
    }
    return value;
  }

  public void setValue(int i) {
    value = i;
    statusByte = VALUE_FIELD;
  }

  public void retrieve(ByteBuffer bb) {
    statusByte = bb.get();
    value = bb.getInt();
  }

  public void store(ByteBuffer bb) {
    bb.put(statusByte);
    bb.putInt(value);
  }

  public int getStoredLength() {
    return 5;
  }

  public int compareTo(IndexKey key) {
    if (key == null) {
      throw new IllegalArgumentException("Supplied key is null");
    }
    if (key == this) {
      return 0;
    }
    if (key.getClass() != getClass()) {
      throw new IllegalArgumentException(
          "Supplied key is not of the correct type");
    }
    IntegerKey other = (IntegerKey) key;
    int result = statusByte - other.statusByte;
    if (result == 0 && statusByte == VALUE_FIELD) {
      result = value - other.value;
    }
    return result;
  }

  public final boolean isNull() {
    return statusByte == NULL_FIELD;
  }

  public final boolean isMinKey() {
    return statusByte == MINUS_INFINITY_FIELD;
  }

  public final boolean isMaxKey() {
    return statusByte == PLUS_INFINITY_FIELD;
  }

  public final boolean isValue() {
    return statusByte == VALUE_FIELD;
  }

  public boolean equals(Object o) {
    if (o == null) {
      throw new IllegalArgumentException("Supplied key is null");
    }
    if (o == this) {
      return true;
    }
    if (o == null || !(o instanceof IntegerKey)) {
      return false;
    }
    return compareTo((IntegerKey) o) == 0;
  }

  public void parseString(String s) {
    if ("<NULL>".equals(s)) {
      statusByte = NULL_FIELD;
    } else if ("<MINKEY>".equals(s)) {
      statusByte = MINUS_INFINITY_FIELD;
    } else if ("<MAXKEY>".equals(s)) {
      statusByte = PLUS_INFINITY_FIELD;
    } else {
      value = Integer.parseInt(s);
      statusByte = VALUE_FIELD;
    }
  }

  public String toString() {
    if (isNull()) {
      return "<NULL>";
    } else if (isMinKey()) {
      return "<MINKEY>";
    } else if (isMaxKey()) {
      return "<MAXKEY>";
    } else {
      return Integer.toString(value);
    }
  }

  public static IntegerKey createNullKey() {
    return new IntegerKey(NULL_FIELD, 0);
  }

  public static IntegerKey createMinKey() {
    return new IntegerKey(MINUS_INFINITY_FIELD, 0);
  }

  public static IntegerKey createMaxKey() {
    return new IntegerKey(PLUS_INFINITY_FIELD, 0);
  }
}
\end{verbatim}

Shown below is the corresponding \verb|IndexKeyFactory| implementation.

\begin{verbatim}
public class IntegerKeyFactory implements IndexKeyFactory {

  public IndexKey maxIndexKey(int containerId) {
    return IntegerKey.createMaxKey();
  }

  public IndexKey minIndexKey(int containerId) {
    return IntegerKey.createMinKey();
  }

  public IndexKey newIndexKey(int containerId) {
    return IntegerKey.createNullKey();
  }
}
\end{verbatim}

The example shown above is a simple key. It is possible to create 
multi-attribute keys as well. For an example of how this can be done,
please see the sample \verb|typesystem| package supplied with SimpleDBM,
and the sample project \verb|tupledemo|.

\section{Locations}

Indexes contain pointers to tuple data. Such pointers must implement the
\verb|org.simpledbm.rss.api.loc.Location| interface, and an implementation of
\verb|org.simpledbm.rss.api.loc.LocationFactory| must be available to SimpleDBM so that
it is able to create new Location instances.

\section{Creating a new index}

Following code snippet shows the steps required to create a new
index.

\begin{verbatim}
int INDEX_KEY_FACTORY_TYPE = 25000;
int LOCATION_FACTORY_TYPE = 25001;

ObjectRegistry objectRegistry = ...;
LocationFactory locationFactory = ...;
IndexKeyFactory indexKeyFactory = ...;
IndexManager indexManager = ...;
TransactionManager transactionManager = ...;

// Register key factory
registry.register(INDEX_KEY_FACTORY_TYPE, indexKeyFactory);

// Register location factory
registry.register(LOCATION_FACTORY_TYPE, locationFactory);

Transaction trx = transactionManager.begin();
boolean success = false;
try {
  int containerId = 1;
  int extentSize = 8;
  boolean isUnique = true;
  indexManager.createIndex(trx, "testbtree.dat", 
    containerId, extentSize, INDEX_KEY_FACTORY_TYPE, 
    LOCATION_FACTORY_TYPE, isUnique);
} finally {
  if (success)
    trx.commit();
  else
    trx.abort();
}
\end{verbatim}

\section{Obtaining index instance}

In order to manipulate an index, you must first obtain an instance of the
index. This is shown below:

\begin{verbatim}
int containerId = 1;
Index index = indexManager.getIndex(containerId);
\end{verbatim}

\section{Working with keys}

\subsection{Adding a key}

To add a key, you need the \verb|IndexKey| instance and the \verb|Location| instance.

\begin{verbatim}
// To make it more interesting, lets add 200 keys
Transaction trx = transactionManager.begin();
boolean success = false;
try {
  int containerId = 1;
  Index index = indexManager.getIndex(containerId);
  IndexKey key = indexKeyFactory.newIndexKey(containerId);
  Location location = locationFactory.newLocation();
  trx.acquireLock(location, LockMode.EXCLUSIVE, LockDuration.COMMIT_DURATION);
  index.insert(trx, row, location);
  success = true;
} finally {
  if (!success) {
    trx.abort();
  }
  else {
    trx.commit();
  }
}
\end{verbatim}

Note that prior to inserting the key, the associated location must be
locked for commit duration. 

\subsection{Deleting a key}

Deleting a key is very similar to adding a key.

\begin{verbatim}
// To make it more interesting, lets add 200 keys
Transaction trx = transactionManager.begin();
boolean success = false;
try {
  int containerId = 1;
  Index index = indexManager.getIndex(containerId);
  IndexKey key = ...;
  Location location = ...;
  trx.acquireLock(location, LockMode.EXCLUSIVE, LockDuration.COMMIT_DURATION);
  index.delete(trx, row, location);
  success = true;
} finally {
  if (!success) {
    trx.abort();
  }
  else {
    trx.commit();
  }
}
\end{verbatim}

Note that prior to deleting the key, the associated location must be
locked for commit duration. 

\section{Scanning keys}

\subsection{Isolation Modes}

Before describing how to scan keys within an Index, it is necessary to
describe the various lock isolation modes supported by SimpleDBM.

\subsubsection{Assumptions regarding locking}

\begin{itemize}
\item All locking is on Locations only. 
\item When a tuple is inserted or deleted, its Location is first locked in EXCLUSIVE mode, the tuple is inserted or deleted from data page, and only after that, indexes are modified. 
\item Updates to indexed columns are treated as key deletes followed by key inserts. The updated row is locked in EXCLUSIVE mode before indexes are modified. 
\item When fetching, the index is looked up first, which causes a SHARED or UPDATE mode lock to be placed on the row, before the data pages are accessed.
\end{itemize}

\subsubsection{Read Committed/Cursor Stability}

The location is locked while the cursor is positioned on the key. The lock on current location is
released before the cursor moves to the next key.

Fetch: SHARED lock is obtained on found key or next key for manual duration. SHARED lock on current key/next key is released before moving cursor to next key. However, in the not found case, lock on next key is released immediately after the fetch (making the SHARED lock effectively instant duration). For update cursors, same rules apply except that the lock mode is UPDATE. 

Insert: Instant duration EXCLUSIVE lock on next key is acquired (inserted key already locked by caller). For unique indexes only, SHARED lock is requested on insert key if it is found to already exist, and if lock is granted, return unique constraint violation error and the SHARED lock is released. 

Delete: Commit duration EXCLUSIVE lock on next key is requested (deleted key already locked by caller). 

\subsubsection{Repeatable Read (RR)}

Fetch: S lock on found key or next key for commit duration. In case of U mode cursors, U lock (if it has not been converted to X lock already) should be downgraded to S lock before the cursor moves to the next row. (I think in the not found case, next key lock should be for manual duration only and released after the fetch is complete, as we are not trying to avoid phantoms but only check that there is not an uncommitted delete that would have been fetched). 

Insert: Instant duration X lock on next key (inserted key already locked by caller). (I think this is only required for unique indexes). For unique indexes only, request S lock on found key for commit duration, and if lock is granted, return unique constraint violation error. 

Delete: Same as CS. 

\subsubsection{Serializable}
Fetch: Same as RR, except that reads should lock next key in the not found case for commit duration. 

Insert: Same as RR except that for non unique indexes too, inserts should lock next key for instant duration. 

Delete: Same as RR. 




\end{document}
